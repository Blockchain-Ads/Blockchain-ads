function getTime() {
    return new Date().getTime() / 1000
}

/**
 * @param key {string|RegExp}
 * @param policies {Map<string|RegExp, number>}
 * @returns {any}
 */
function getLifespan(key, policies) {
    for(const policy of policies.entries()) {
        if (policy[0] instanceof RegExp) {
            const value = policy[0].test(key)
            if (value) {
                return policy[1]
            }
        }
        if (policy[0] === key) {
            return policy[1]
        }
    }
    return 0
}

let m_cache

export class Cache {
    constructor(storage = {}) {
        this.policy = new Map()
        this.storage = storage
    }

    /**
     * @param key {string|RegExp}
     * @param lifespan {number}
     */
    addPolicy(key, lifespan) {
        this.policy.set(key, lifespan)
        return this
    }

    /**
     * @param key {string}
     * @param callback {() => Promise<any>}
     * @returns {Promise<any>}
     */
    async cache(key, callback) {
        const lifespan = getLifespan(key, this.policy)
        const prefixedKey = 'cache:' + key;
        if (lifespan) {
            const value = this.storage[prefixedKey]
            if (value) {
                const object = JSON.parse(value)
                if (getTime() <= object.expires) {
                    return object.value
                }
            }
            const newValue = await callback()
            this.storage[prefixedKey] = JSON.stringify({
                expires: getTime() + lifespan,
                value: newValue
            })
            return newValue
        } else {
            return await callback()
        }
    }

    /**
     * @param key {string|RegExp}
     * @return {void}
     */
    invalidate(key) {
        for(const storageKey in this.storage) {
            if (key instanceof RegExp) {
                if (key.test(storageKey)) {
                    delete this.storage[storageKey]
                }
            } else if (key === storageKey) {
                delete this.storage[storageKey]
            }
        }
    }
    /**
     * @param cacheBuilder {() => Cache}
     * @returns {void}
     */
    static use(cacheBuilder) {
        m_cache = cacheBuilder(m_cache)
    }

    /**
     * @returns {Cache}
     */
    static get() {
        if (!m_cache) {
            m_cache = new Cache()
        }
        return m_cache
    }
}

/**
 * @param key {string}
 * @param callback {() => Promise<any>}
 * @returns {Promise<any>}
 */
export function cache(key, callback) {
    return Cache.get().cache(key, callback)
}

/**
 * @param key {string|RegExp}
 * @returns {void}
 */
export function invalidate(key) {
    Cache.get().invalidate(key)
}

export function escapePolicyPart(string) {
    return string.toString().replace(/[.*+?^${}()|[\]\\]/g, '\\$&')
}