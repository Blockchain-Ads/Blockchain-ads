import {Application, User, BaseAuth, BaseApi} from "@vulos/identity-base"
import { StateVerifier } from "./StateVerifier.js"
import { UserInfo } from "@vulos/identity-base/lib/UserInfo.js";
import { OidcClient } from 'oidc-client'

class FrontendAuth extends BaseAuth {
    /**
        @param application {Application}
        @param endpoint {string?}
     */
    constructor(application, endpoint) {
        super(application, endpoint)
    }

    /**
     * Set a refresh token callback function
     * @param fn {(refreshToken : string) => Promise<void>}
     * @return {Promise<void>}
     */
    async setRefreshTokenCallback(fn) {
        this.refreshTokenCallback = fn
    }
    /**
     * Create an authentication URL
     * @param authVerifier {any}
     * @returns {Promise<string>}
     */
    async createAuthUrl(authVerifier) {
        if (!this.client) {
            throw new Error("Please call the connect() method before preforming any action on this object")
        }
        const request = await this.client.createSigninRequest({
            state: authVerifier.state
        })
        return request.url
    }
    /**
     * @param accessToken {string}
     * @returns {Promise<UserInfo>}
     */
    async getUserInfo(accessToken) {
        if (!this.client) {
            throw new Error("Please call the connect() method before preforming any action on this object")
        }
        const accessTokenUser = { getAccessToken() { return accessToken }};
        const connectApi = new BaseApi(accessTokenUser, this.endpoint + '/connect')
        return new UserInfo(await connectApi.request('userinfo'))
    }

    /**
     * @param refreshToken {string}
     * @returns {Promise<{access_token?: string, refresh_token?: string, id_token?: string, token_type?: string, expires_at?: number}>}
     */
    async refreshTokens(refreshToken) {
        if (!this.client) {
            throw new Error("Please call the connect() method before preforming any action on this object")
        }
        if (!this.refreshTokenCallback) {
            throw new Error('The token is expired and no refresh token callback has been set')
        }
        await this.refreshTokenCallback.apply(this, [refreshToken])
    }
    /**
     * Process the callback arguments
     * @param authVerifier {StateVerifier}
     * @param params {any}
     * @returns {Promise<User>}
     */
    async processCallback(authVerifier, params) {
        if (!this.client) {
            throw new Error("Please call the connect() method before preforming any action on this object")
        }
        try {

            const response = await this.client.processSigninResponse(params);
            if (response.state !== authVerifier.state) {
                throw new Error("Invalid state");
            }

            const tokenSet = {
                accessToken: response.access_token,
                refreshToken: response.refresh_token,
                idToken: response.id_token,
                tokenType: response.token_type,
                expiresAt: Math.floor(Date.now() / 1000) + response.expires_in
            }

            window.top.postMessage(tokenSet)
            if (authVerifier['silent']) {
                return null
            }
            return new User(this, tokenSet)

        } catch(e) {
            if (authVerifier['silent']) {
                window.top.postMessage({fail: true})
                return null
            }
            throw e
        }

    }

    async connect() {
        const settings = {
            authority: this.endpoint,
            client_id: this.application.id,
            client_secret: this.application.secret,
            response_type: this.application.responseTypes[0],
            redirect_uri: this.application.redirectUrls[0],
            scope: this.application.scope
        }
        if(this.application.postLogoutRedirectUrls.length > 0) {
            settings.post_logout_redirect_uri = this.application.postLogoutRedirectUrls[0]
        }
        this.client = new OidcClient(settings)

    }

    /**
     * Create an authentication verifier object
     * @returns {StateVerifier}
     */
    createVerifier() {
        const silentVerifier = localStorage.getItem('silent_verifier')
        if (silentVerifier) {
            localStorage.removeItem('silent_verifier')
            const verifier = JSON.parse(silentVerifier)
            verifier['silent'] = true
            return verifier
        }
        return new StateVerifier()
    }
}

export {
    FrontendAuth, StateVerifier, User
}